'''
최단거리로 가는게 아니라 최대한 행성의 경계를 통과 하지 않는 것
곡선도 가능
출발점이나 도착점이 행성의 경계 안에 존재하지 않는다면 전부 피해서 지나갈 수 있다.
어떻게 출발점이나 도착점이 행성의 경계안에 있지 않다는 것을 체크할 것인가가 쟁점이 될 것으로 보임
- 원의 중심과 출발/도착의 거리가 r보다 작은지 보면 될듯
행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다.
또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.
또 무조건 경계 안에 있다고 체크를 다 하면 문제가 생기는게
같은 경계안이라면 안지나가고도 가능하니까
그렇다면 선을 그어서 확인을 해야할까

1. 출발과 도착이 너무 가까워서 하나의 원 안에 있는 경우
- 원끼리 교차나 접하는 경우/ 출발이나 도착이 원에 접하는 경우가 없으므로 무조건 0번만에 도착 가능하다
- 모든 원에 대해서 출발과 도착을 체크하는게 맞을 듯, 돌다가 한 원안에 있네 싶으면 브레이크하고 0출력하는 방식
2. 같은 원 안에 있지 않은 경우
- 출발과 도착이 몇 개의 원 안에 있는지 체크하고

이걸 포괄해서 반복문으로 원마다 돌아가면서 출발이 원 안인지, 도착이 원 안인지 체크하고
둘 다 안이면 더하고 빼고 하면서 체크하고
원 별로 리스트 만들어서 안에 있을 때 마다 더해서 체크한다음에 2의 나머지로 계산해서 최종합하면
둘 다 안이면 0이니까 괜찮지 않나

'''
import sys

ssr = sys.stdin.readline

t = int(ssr())
for _ in range(t):
    points = list(map(int, ssr().split()))
    n = int(ssr())
    planets =[list(map(int, ssr().split())) for _ in range(n)]
    ans = 0
    for i in range(n):
        if ((points[0] - planets[i][0])**2 + (points[1] - planets[i][1])**2 - planets[i][2]**2) *  ((points[2] - planets[i][0])**2 + (points[3] - planets[i][1])**2 - planets[i][2]**2) < 0:
            ans += 1
    print(ans)