'''
벽을 하나는 부숴도 됨 = 보통 이건 브루트포스 하라는 말인데
그래프 탐색을 하는데 n*m 번이나 반복 탐색하면 브루트 포스를 하면 시간제한이 걸리지 않을까
1000*1000에 1이 몇개 들어올진 모르겠는데 절반 들어온다쳐도 50만번을 돌려야하는데
하나씩 다 지워가면서 직접하는건 불가능한 방법일 거 같은데

간선 가중치가 없으니까 BFS 써도 될거 같은데
뚫어도 되는 벽을 뭘 선택하지...

현재 좌표, 이동거리, 벽을 뚫은 횟수를 인수로 bfs를 사용하면 어때
벽을 뚫은 횟수가 0이면 벽을 만나더라도 큐에 넣는거지
벽을 뚫은 횟수가 1이면 그 다음 벽을 만났을 때 그냥 아무것도 없이 끝
해볼만할 거 같은데

아니면 플로이드 워셜을 해서 노드간 거리를?
일단 이건 아닌거 같기도 하고

(1, 1)이 출발, (n, m)이 도착 파이썬 인덱스로 볼 때는 각각 1씩 빼주면 됨

최단거리를 출력하는데 불가능할때는 -1
최단거린데 불가능? = 목적지에 도착할 수 있는 길이 없다

벽을 뚫고 온게 최단거리 일 수 있는데 이미 방문처리가 되어서 코드가 안도는 일도 있겠네
그러면 노드의 모든 최단거리를 저장하는 배열이 필요하겠다

반대로 벽을 안뚫고 온 쪽이 결과적으로는 최단거리 또는 가능한 경로인데
벽을 뚫고와서 먼저 최단거리를 차지한 쪽이 최단거리를 갱신해놓으면 문제가 생기네
근데 그렇다고 방문처리를 안하자니 위로갔다 아래로 갔다를 반복하면서 q가 안끝날텐데
두 번까지는 봐주면 어때 visited를 0으로 초기화 하고 1이어도 추가는 해주되 2면 추가 안해주는거지

이거도 안돼 한 노드에 최대 4방향에서 다시 접근이 가능하니까 5회 이하로 해야할거 같은데
근데 벽을 2개 못넘는게 있으니까 굳이 그걸 신경쓸 필요 있나 싶긴 한데

아무튼 장래성 때문에 단순하게 최단거리만 나왔다고 땡이 아니야
벽을 아직 안뚫은 쪽이 아무래도 장래성이 있지
그렇다고 벽을 이미 뚫은 쪽이 의미가 없는 건 아닌데
확실하게 목적지에서 벽을 한 번 뚫어야 하는 상황이라면 좀 돌아왔더라도 아직 벽을 안둟은 쪽이 가능하지

벽을 뚫고 온 놈이 상대적으로 빠르게 올 수 밖에 없는데
벽을 한 번 뚫은 놈이라 다시 벽을 뚫을 일이 없는데 이동거리만 짧은거지
그래서 목적지로 가기 위해 벽을 한 번 더 뚫어야 할 경우 얘는 절대 목적지에 도달할 수 없지만
방문처리만 까먹는 놈이 되는거야
아니면 방문처리는 됐어도 아직 벽을 뚫은 적이 없다면 일단 큐에 넣어줄까?
이건 안돼 아예 벽이 없으면 q 계속 커져서 메모리 터져

벽을 뚫고 지나간 놈은 방문처리를 할 때 1로 하고
벽을 안뚫은 놈은 방문처리를 할 때 2로 하면 어때
벽을 뚫은 놈은 방문을 0만 지나갈 수 있고
벽을 안뚫은 놈은 0이랑 1은 지나갈 수 있는거지

'''

from collections import deque
import sys
ssr = sys.stdin.readline

INF = 1000001

def bfs():
    dpos = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    visited = [[0 for _ in range(m)] for _ in range(n)]
    visited[0][0] = 1
    q = deque([(0, 0, 0, 0)])
    ans = INF
    while q:
        r, c, distance, break_wall = q.popleft()
        if r == n-1 and c == m-1:
            ans = min(ans, distance)
        for dr, dc in dpos:
            if 0 <= r+dr < n and 0 <= c+dc < m: # 이동할 위치가 보드 위일 때
                if break_wall == 1: # 벽을 뚫은 경로라면
                    if visited[r+dr][c+dc] == 0: # 벽을 뚫었으니까 방문 0일때만 가능
                        if board[r+dr][c+dc] == '0': # 벽을 더 이상 뚫을 수 없음, 즉 벽이 아닐 땐,ㄴ
                            q.append((r+dr, c+dc, distance+1, 1))
                            visited[r+dr][c+dc] = 1
                else: # 벽을 뚫은 적 없는 경로라면
                    if visited[r+dr][c+dc] < 2: # 미방문이거나 벽을 뚫은 놈이 방문한 적 있거나
                        if board[r+dr][c+dc] == '0': # 길이면
                            q.append((r+dr, c+dc, distance+1, 0))
                            visited[r+dr][c+dc] = 2
                        else: # 벽이면
                            q.append((r+dr, c+dc, distance+1, 1))
                            visited[r+dr][c+dc] = 1
    return ans+1 if ans != INF else -1
                        
n, m = map(int, ssr().split())
board = [ssr().rstrip() for _ in range(n)]
print(bfs())

'''
3 3
011
011
010

5 5
01000
01010
01010
01011
00010
'''