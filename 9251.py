'''
아마 한 번 풀어본 적 있는 문제긴 할거임
근데 전혀 기억이 안나네
dp라는걸 알아도 푸는 방법을 모르겠다

풀이를 보든 안보든 이건 확실하게 짚고 넘어가자

항상 수열이 바로 붙은것만 해당하는 건 아니고
점프를 하더라도 그 순서가 맞기만 하다면 상관없음
ex) 123456789, 24789 일 때 최장 공통 부분 수열은 789가 아니라 24789

그럼 어떻게 하면 떨어져있는것도 같은 수열이라고 생각하게 만들 수 있을까

일단 해결을 위해 필요할 것 같은 기능들을 써보자

앞으로는 문제를 보면 필요할 기능, 순서 등을 작성해서 플로우차트를 굳이 차트는 아니더라도 그런걸 써보자
의사코드를 한국어로 쓰는 셈이지, 먼저 큰 기능이나 순서를 잡고 세분화해도 좋고

기능:
같은 문자를 찾는 기능 - 일단 같은 문자를 찾아야 갯수를 세든지 뭐든지 하지 않을까?

근데 진짜 전혀 모르겠네

쉽게 생각할 수 있는 건 아무 문자열을 시작해서 최초의 같은 문자가 나올 때 까지 반복문을 돌리고
찾으면 그 다음 문자가 최초 같은 문자보다 더 뒤에 있는지 보고, 그 다음 문자를 방금 발견한 위치 뒤로 또 보고
하면서 전부 다 보는건데 단점은 시간이 엄청나게 많이 걸린다는 거랑
그게 최대 길이가 아닐 가능성이 있다는거지
- 예를 들어서 C를 찾고 A를 찾고 저 뒤에서 P를 찾았는데 혹시 AP를 건너 뛰고 찾았다면 더 긴 공통 수열이 된다든가
그래서 이렇게 하나씩 이중반복문 죽어라 돌려가면서 보는 건 안된다

그럼 어떻게 해~
dp를 써야한다는거에서 힌트를 좀 받아보면
길이가 1일 때 가능한거 조합들 쫙 보고
길이가 2일 때 가능한 거 쫙 보고 이렇게 해야하나?

전에 비슷한 문제를 풀어봤던 적이 있는데 그거랑은 약간 다르게 입력이 두 개임, 그리고 공통이어야 함

일단 문자 하나를 잡는 거 까지는 동일
그 다음에 오는 문자를 써서 가능한지 체크, 가능하면 다음 번 인덱스를 채우러 넘어가고
안되면 끝내고

그냥 푸는 법은 알겠는데 아직 이게 왜 이렇게 해야하는지 이해는 못하는거 같은 느낌?
'''

s1, s2 = input(), input()
lcs = [[0 for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]
for i in range(1, len(s1)+1):
    for j in range(1, len(s2)+1):
        if s1[i-1] == s2[j-1]:
            lcs[i][j] = lcs[i-1][j-1] + 1
        else:
            lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1])
print(lcs[len(s1)][len(s2)])