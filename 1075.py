'''
n = int(input())
f = int(input())
q = n // f
print(str(q*f)[-2:])
'''
'''
n = int(input())
f = int(input())
tmp = n // f * f
if int(str(tmp)[:-2]) < int(str(n)[:-2]):
    print(str(tmp + f)[-2:])
else:
    n = int(str(n)[:-2]+'00')
    tmp = n // f * f
    if tmp == n:
        print(str(tmp)[-2:])
    else:
        print(str(tmp + f)[-2:])
'''
n = int(input()[:-2] + '00')
f = int(input())
while True:
    if n % f == 0:
        break
    n += 1
print(str(n)[-2:])
'''
n의 뒤에서 두자리 숫자를 바꿔서 f의 배수가 되도록
이왕이면 n이 최대한 작게 만들어줘
가장 간단한 방법은 나눈 다음에 몫 * f 해서 뒤 두 자리 출력하는거지
자릿수가 크면 좀 더 작은 숫자로 바꿀 수 있음
그리고 1000이랑 3의 경우 몫 * 3 하면 999인데 n의 뒤 두자리를 바꾸는거라 1002여야 해서 조건에 맞지 않다면 오히려 수를 키워야 하는 경우도 있음

사람이 이걸 풀 때는 어떻게 하려나?
일단 n을 확인하겠지
그리고 뒤의 두자리를 일단 미지수로 치환하고 생각할 거 같애
1000이랑 3이면
10xx랑 3으로
이렇게 한 다음에 3의 배수 중에서 앞에 10이 될 때까지 수를 키워보겠지

위에서 했던 거처럼 q를 구하는 건 그대로 하되 q에서 뒤에 두자리 뗀거랑 n에서 뒤에 두 자리 뗀거 비교하면 어떨까
그래서 만약에 같거나 크면(클리는 없겠지만) 점점 줄여나가는거지(아니면 앞자리가 다른 제일 큰 수를 찾든지)
작으면 수를 키워보는 거지 앞의 자리가 같아질 때 까지

만약에 1099랑 3이 나오면 1002로 고쳐야 한다는 얘기지

아예 처음부터 뒷자리를 다 없애고
그 조건에 맞는 숫자를 찾으면 어때?
예를 들어서 23442 75라면
23400 75로 바꿔서
나눠떨어지면 00
아니면 tmp 뒤에 두자리
'''