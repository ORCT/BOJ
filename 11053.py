n = int(input())
a = list(map(int, input().split()))
dp = [1 for _ in range(n)]
for i in range(n):
    for j in range(i+1,n):
        if a[j] > a[i]:
            dp[j] = max(dp[j], dp[i]+1)
print(max(dp))


'''
예를 들면 이런 일도 있겠지
600~1000까지 먼저 나오고 남은 거에서 1~599까지 나오면 뒤가 훨씬 길이가 기니까
처음에 나온 값을 min으로 설정해서 min을 계속 증가시켜가면서 갯수를 세는 건 완전한 정답이 될 순 없는 거지
그렇다고해서 a.index(min(a)) 부터 하는 것도 정답이 아닐 수 있지
2~1000까지 하고 그 뒤에 1이면 답이 1일테니까
이중 반복문을 사용하면 어때
어차피 1000개니까 최대한으로 다돌아도 10^6인데 그거보다는 작게 돌거든
처음꺼부터 하나하나 다 탐색하면서 i에 대해 모두 길이를 구하는 거지
그러고 max로 뽑으면 돼
10 20 11 12 13 14 15 16 17 18 30
저 수열이면 어떡할래
10 11 12 13 ~ 30을 뽑는게 정답인데 지금 쓰는 방법으로는 답을 못만들지
각각의 위치에 대한 최적의 값을 구할 수 있을까? dp처럼
수열의 마지막 값과 그 길이를 인덱스마다 저장한 dp 배열을 하나 만든다면
처음에는 dp[0] = (10,1), dp[1] = (20,2)
dp[2] = (20,2)인가? 아니 (11,2)가 되어야 한다. 이 경우에 min_val은 크기가 작은 놈으로 한다지만
그랬을 때 그게 진짜 최적의 값이라고 판단할 수 있을까?
10 20 22 11 12 13 30 이렇다면 어쩔래
10 20 11 12 13 21 22 23
작은게 나오면 무조건 바꾸는 쪽이 좀 더 유리하긴 한가?
10 12 13 14 24 15 16 17 30 작은게 나온다고 바꾸는 쪽이 무조건 유리하지는 않네
시작이랑 마지막 값이랑 길이를 dp에 넣으면?
고민을 하고 있는 이유가 무엇인가
부분수열의 맨 마지막 값보다 작은 값이 나중에 나왔을 때 해당 값부터 다시 부분수열을 만드는게
최적의 해일수도 있고 아닐수도 있기 때문
그리고 그게 몇번이나 반복될지도 사실 잘 모르겠기 때문
그렇다고 이걸 n^3으로는 못쓰지

사람한테 이걸 시키면 어떻게 풀까?
당연히 첫번째 수를 선택해서 첫번째꺼보다 큰 게 나올때 까지 밀고 가겠지
사실 첫번째 수보다 작은 수가 나오면 다음번에 그 수에서 한 번 더 시작하면 되지만
두번째나 세번째처럼 이미 진행하다 보니까 나온 수가 중간에 있는 수들보다 작으면 골치아프지
이 경우에는 하던대로 가는게 긴지, 새로 나온 놈을 사용해서 다시 생각하는게 이득인지를 따져야함
참고로 새로 찾은 놈은 중간에 들어가는게 아니라 거기서 부터 다시 시작하는거임
10 20 30 40 50 11 12 13 14 15...
10 20 30 40 50 20 21 22 23...
'''