'''
후위 표기법 : 연산자가 피연산자 뒤에 위치함
그렇다고 모든 연산자가 다 오른쪽으로 가고 피연산자는 다 왼쪽으로 가는 건 아니고
걍 적당히 섞여있음

중위 표기식을 후위 표기식으로 바꾸는 방법
연산자의 우선순위에 따라 괄호로 묶어줌 -> 연산자를 괄호 오른쪽으로 뺌

이미 괄호가 붙어서 입력이 오는 경우도 있음에 주의

괄호가 제일 우선순위가 높다
우선순위 괄호 > 곱, 나 > 덧, 뺄
괄호 안에서도 당연히 같은 순서를 유지한다.

괄호가 보일 때 마다 재귀 호출을 하고
( 얘가 안나오다가 ) 얘가 나오면 이제 이 안에는 괄호가 없다는 뜻이잖아
그러면 이제 괄호 있나요? 하는 반복문을 끝내고 곱셈 덧셈으로 돌리고 싶은데
그럼 끝나는 인덱스도 받아야 하고
괄호 원래 있는 것도 없애야 함

후위 표기로 바꾼 파트는 피연산자 하나처럼 취급해야함

그래서 이렇게 for 반복으로 인덱스로 접근하는게 좀 에러를 일으키기 쉬운 형태인거 같은데

뭔가 머리속에 아이디어는 떠오르는데
문자열을 후위 표기로 바꿨을 때 그걸 피연산자 하나처럼 취급할 방법을 모르겠네
거기다 재귀 탈출을 했을 때 원래 배열에도 그게 반영이 되어 있어야 그걸 가지고 다시 후위 표기로 바꾸든가 하는데

플로우
1. 입력을 받는다
2. 입력 문자열에 대해 괄호, 곱나, 덧뺄의 연산을 총 세번 루프 돌면서 확인한다.
3. 괄호가 있을 경우에 시작 인덱스를 '(' 괄호의 위치로 변경해 재귀 호출한다.
4. ')' 괄호가 나오면 end를 닫는 괄호의 위치로 갱신하고 괄호 여부 반복문을 종료한다.
5. 갱신된 start와 end에 대해서 곱나 연산이 있는지 체크한다.
5-1. 있을 경우 part에 후위 표기로 변환했을 때의 식을 저장한다.

괄호를 아예 안지우고 나중에 다 빼버리면 어때
괄호 안에 연산이 여러개 있으면 

전공자들은 자료구조 수업에서 한 번씩은 해본다는데
나는 뭐 전공자가 아니라스...

isalpha는 c로 돌아서 빠른건가...
그럼 in도 사실 마찬가지 아닌가...

'''
def f(equation):
    priority = {'+':1, '-':1,'*':2,'/':2,'(':0}
    stack = []
    for i in equation:
        if i.isalpha():
            print(i, end='')
        else:
            if len(stack) == 0 or i == '(':
                stack.append(i)
            elif i == ')':
                while True:
                    tmp = stack.pop()
                    if tmp == '(':
                        break
                    else:
                        print(tmp, end='')
            else:
                while True:
                    if len(stack) != 0 and priority[stack[-1]] >= priority[i]:
                        print(stack.pop(), end='')
                    else:
                        break
                stack.append(i)
    while stack:
        print(stack.pop(), end='')
            
equation = input()
f(equation)